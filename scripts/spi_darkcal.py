import sys
import os
import argparse
import yaml
import h5py
import time
import shutil
import numpy as np
from PIL import Image
from spipy import analyse, image
from mpi4py import MPI

comm = MPI.COMM_WORLD
m_rank = comm.Get_rank()
m_size = comm.Get_size()

def write_log(filename, info, value):
	with open(filename, "w") as fp:
		for i,k in enumerate(info):
			fp.write("%10s : %10s\n" % (k, str(value[i])))

if __name__ == '__main__':
	
	# parse cmd arguments
	parser = argparse.ArgumentParser(
		allow_abbrev=False,
		description = "Single-particle diffraction hit finder.")
	parser.add_argument("-l", "--evtlist", type=str, help="Event list file generated by spi_events.", required=True)
	parser.add_argument("-o", "--outfolder", type=str, help="Specify a folder for output files (the program will create it if it doesn't exist).", required=True)
	parser.add_argument("--res", type=float, default=4, help="Singals whose 'I > mean_I + res * std_I' or 'I < mean_I - res * std_I' will be masked out. Default=4.")
	parser.add_argument("--maskfile", type=str, default="none", help="Mask file, HDF5/CXI or .npy file. Masked pixels have the value of 1. Default is none.")
	parser.add_argument("--mask_h5loc", type=str, default="none", help="The mask data location if --maskfile is HDF5 file, default is none.")
	parser.add_argument("--initc", type=str, default="none", help="A roughly estimated center location, 'Cx,Cy', default is using geometry center.")
	parser.add_argument("-j", type=int, default=1, help="Number of processes, default=1.")
	args = parser.parse_args()

	# get parameters
	# check output folder
	if m_rank == 0:
		if not os.path.isdir(args.outfolder):
			os.mkdir(args.outfolder)
		output_folder = args.outfolder
		events_file = os.path.join(output_folder, "events.lst")
		shutil.copy(args.evtlist, events_file)
	# event list file
	with open(args.evtlist, "r") as fp:
		evts = fp.read()
	evts = yaml.load(evts, Loader=yaml.FullLoader)
	# check initc
	if args.initc.upper() != "NONE":
		est_center = list(map(float, args.initc.split(',')))
		if len(est_center) != 2:
			print("The value of option --initc is invalid.")
			sys.exit(0)
	# mask
	if args.maskfile.upper() != "NONE":
		if not os.path.exists(args.maskfile):
			if m_rank == 0: print("[Error] Input maskfile is invalid.")
			sys.exit(0)
		mext = os.path.splitext(args.maskfile)[-1].lower()
		try:
			if mext == ".npy":
				mask = np.load(args.maskfile)
			elif mext == ".h5" or mext == ".cxi":
				with h5py.File(args.maskfile, 'r') as fp:
					mask = fp[args.mask_h5loc][()]
			else:
				raise RuntimeError("Unknown mask file format %s" % mext)
		except Exception as err:
			if m_rank == 0: print("[Error] Fail to load mask file (%s)." % err)
			sys.exit(0)
	else:
		mask = None
	# get time
	if m_rank == 0:
		start_time = time.time()

	# calibration
	files = evts.keys()
	pi = 0
	num_pattern = 0
	powder = None
	for i, file in enumerate(files):
		fext = os.path.splitext(file)[-1].lower()
		datasets = evts[file].keys()
		if fext == ".h5" or fext == ".cxi":
			with h5py.File(file, 'r') as fp:
				for j, dt in enumerate(datasets):
					num = evts[file][dt][0]
					dt_dim = len(fp[dt].shape)
					if powder is None:
						powder = np.zeros(evts[file][dt][1])
					for k in range(num):
						if pi % m_size != m_rank:
							pi += 1
							continue
						if dt_dim == 2: powder += fp[dt][()]
						else: powder += fp[dt][k]
						pi += 1
						num_pattern += 1
		elif fext == ".tif":
			if pi % m_size != m_rank:
				pi += 1
				continue
			dt = list(evts[file].keys())[0]
			if powder is None:
				powder = np.asarray(Image.open(file))
			else:
				powder += np.asarray(Image.open(file))
			num_pattern += 1
		else:
			if m_rank == 0: print("Unknown data file format (%s)." % fext)
			sys.exit(0)

	mean_bg = np.zeros(powder.shape)
	comm.Reduce(powder, mean_bg, op=MPI.SUM, root=0)
	num_pattern = comm.reduce(num_pattern, op=MPI.SUM, root=0)

	if m_rank == 0:

		mean_bg /= num_pattern
		mask_bg = np.zeros(mean_bg.shape, dtype=int)
		# bad points
		bad_points = np.where(np.isnan(mean_bg) & np.isinf(mean_bg))
		mean_bg[bad_points] = 0
		mask_bg[bad_points] = 1
		# Iq
		search_r = 10
		friedel_r = max((np.min(mean_bg.shape)//2-search_r-1), 10)
		if args.initc.upper() == "NONE":
			est_center = np.array(mean_bg.shape)//2
		center = analyse.saxs.friedel_search(mean_bg, est_center, mask, search_r, friedel_r)
		meanbg_Iq = image.radp.radial_profile(mean_bg, center, mask)
		meshgrids = np.indices(mean_bg.shape)
		rinfo = np.sqrt(sum( ((grid - c)**2 for grid, c in zip(meshgrids, center)) ))
		rinfo = np.round(rinfo).astype(np.int)
		# Iq mask
		for r, I, std in meanbg_Iq:
			mask_bg[(rinfo == r) & ((mean_bg > I+std*args.res) | (mean_bg < I-std*args.res))] = 1
		mask_bg[(mask == 1)] = 0
		# save file
		save_h5 = os.path.join(output_folder, "darkcal.h5")
		with h5py.File(save_h5, "w") as fp:
			fp.create_dataset("mask", data=mask_bg, chunks=True)
			fp.create_dataset("bg", data=mean_bg, chunks=True)
			if mask is not None:
				fp.create_dataset("information/user_mask", data=mask.astype(int), chunks=True)
			fp.create_dataset("information/cmd_line", data=" ".join(sys.argv))
		# save log
		end_time = time.time()
		save_log = os.path.join(output_folder, "darkcal.log")
		write_log(save_log, ["patterns", "res", "time"], [num_pattern, args.res, end_time-start_time])