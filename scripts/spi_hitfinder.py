import sys
import os
import argparse
import yaml
import h5py
import time
import shutil
import numpy as np
from PIL import Image
from spipy import analyse, image
from mpi4py import MPI

comm = MPI.COMM_WORLD
m_rank = comm.Get_rank()
m_size = comm.Get_size()

def write_log(filename, info, value):
	with open(filename, "w") as fp:
		for i,k in enumerate(info):
			fp.write("%10s : %10s\n" % (k, str(value[i])))

def cal_shell_index(radii_range, est_center):
	inner_shell = image.radp.circle(2, radii_range[0]) + np.array(est_center).astype(int)
	outer_shell = image.radp.circle(2, radii_range[1]) + np.array(est_center).astype(int)
	shell = np.zeros(mask.shape)
	shell[outer_shell[:,0], outer_shell[:,1]] = 1
	shell[inner_shell[:,0], inner_shell[:,1]] = 0
	shell[np.where(mask > 0)] = 0
	shell_index = np.where(shell == 1)
	return shell_index

def get_label(pat, darkbg, mask, this_shell_index, thres):
	if mask is not None:
		pat = pat * (1 - mask)
	if shell_index is not None:
		chi_score = np.sum( (pat[shell_index] - darkbg[shell_index])**2 )\
				/ np.sum( (darkbg[shell_index] - np.mean(darkbg[shell_index]))**2 )
	else:
		chi_score = np.sum( (pat - darkbg)**2 ) / np.sum( (darkbg - np.mean(darkbg))**2 )
	if chi_score > thres:
		return [chi_score, 1]
	else:
		return [chi_score, 0]

if __name__ == '__main__':
	
	# parse cmd arguments
	parser = argparse.ArgumentParser(
		allow_abbrev=False,
		description = "Single-particle diffraction hit finder.")
	parser.add_argument("-l", "--evtlist", type=str, help="Event list file generated by spi_events.", required=True)
	parser.add_argument("-o", "--outfolder", type=str, help="Specify a folder for output files (the program will create it if it doesn't exist).", required=True)
	parser.add_argument("-c", "--darkcal", type=str, help="Dark calibration file.", required=True)
	parser.add_argument("--thres", type=float, default=10, help="Chi-square threshold, patterns whose chi-qsuare value are larger than the threshold are identified as hit. Default=10.")
	parser.add_argument("--radii_range", type=str, default="none", help="The radii of a ring area used for hit-finding, string like 'Ra,Rb', default='none'.")
	parser.add_argument("--initc", type=str, default="none", help="A roughly estimated center location, 'Cx,Cy', default is using geometry center.")
	parser.add_argument("-j", type=int, default=1, help="Number of processes, default=1.")
	args = parser.parse_args()

	# get parameters
	if m_rank == 0:
		print("- Hit finder : Allocate %d processes successfully." % m_size)
	# check output folder
	if m_rank == 0:
		if not os.path.isdir(args.outfolder):
			os.mkdir(args.outfolder)
		output_folder = args.outfolder
		events_file = os.path.join(output_folder, "events.lst")
		shutil.copy(args.evtlist, events_file)
	# event list file
	with open(args.evtlist, "r") as fp:
		evts = fp.read()
	evts = yaml.load(evts, Loader=yaml.FullLoader)
	# check initc
	if args.initc.upper() != "NONE":
		est_center = list(map(float, args.initc.split(',')))
		if len(est_center) != 2:
			print("The value of option --initc is invalid.")
			sys.exit(1)
	else:
		est_center = None
	# check radii range
	if args.radii_range.upper() != "NONE":
		radii_range = list(map(float, args.radii_range.split(',')))
		if len(radii_range) != 2:
			print("The value of option --radii_range is invalid.")
			sys.exit(1)
	else:
		radii_range = None
	# darkcal
	raw_darkcal = os.path.abspath(args.darkcal)
	if os.path.isfile(raw_darkcal):
		with h5py.File(raw_darkcal, 'r') as fp:
			background = fp["bg"][()]
			mask = fp["mask"][()]
			if "user_mask" in fp["information"].keys():
				mask_user = fp["information/user_mask"][()]
				mask = mask | mask_user
	else:
		print("The dark calibration file is invalid.")
		sys.exit(1)
	# get time
	if m_rank == 0:
		start_time = time.time()
	# save parameters
	if m_rank == 0:
		dark_cal_file = os.path.join(args.outfolder, "darkcal.h5")
		with h5py.File(dark_cal_file, "w") as fp:
			fp.create_dataset("bg", data=background)
			fp.create_dataset("mask", data=mask)
			fp.create_dataset("RawPathString", data=raw_darkcal)
		param_file = os.path.join(args.outfolder, "parameters.log")
		write_log(param_file, ["radii", "thres", "initc"], [args.radii_range, args.thres, args.initc])
		with open(param_file, "a") as fp:
			fp.write("\n")
			fp.write(" ".join(sys.argv))

	# cal shell_index
	shell_index = None
	if est_center is not None and radii_range is not None:
		shell_index = cal_shell_index(radii_range, est_center)

	# start hit finding
	files = evts.keys()
	pi = 0
	num_pattern = 0
	num_hits = 0
	log_file = os.path.join(args.outfolder, "hit_finding_part%d.stat"%m_rank)
	hits = []
	hits_serial = []
	all_score = []
	for i, file in enumerate(files):
		print("- Rank %d : Processing %s ..." % (m_rank, file))
		fext = os.path.splitext(file)[-1]
		datasets = evts[file].keys()
		result_h5_file = os.path.join(args.outfolder, "file%d_"%i+os.path.splitext(os.path.basename(file))[0]+"_part%d.hits.h5"%m_rank)
		if os.path.exists(result_h5_file): os.remove(result_h5_file)
		for j, dt in enumerate(datasets):
			num = evts[file][dt][0]
			if fext == ".h5" or fext == ".cxi":
				if shell_index is None and radii_range is not None:
					this_center = np.array(evts[file][dt][1])/2
					this_shell_index = cal_shell_index(radii_range, this_center)
				else:
					this_shell_index = shell_index
				with h5py.File(file, 'r') as fp:
					dt_dim = len(fp[dt].shape)
					for k in range(num):
						if pi % m_size != m_rank:
							pi += 1
							continue
						if dt_dim == 2: this_pat = fp[dt][()]
						else: this_pat = fp[dt][k]
						chi_score, label = get_label(this_pat, background, mask, this_shell_index, args.thres)
						all_score.append(chi_score)
						pi += 1
						num_pattern += 1
						if label > 0:
							num_hits += 1
							hits.append(this_pat)
							hits_serial.append(k)
							write_log(log_file, ["processed", "hits"], [num_pattern, num_hits])
			elif fext == ".tif":
				if pi % m_size != m_rank:
					pi += 1
					continue
				this_pat = np.asarray(Image.open(file))
				if shell_index is None and radii_range is not None:
					this_center = np.array(this_pat.shape)/2
					this_shell_index = cal_shell_index(radii_range, this_center)
				else:
					this_shell_index = shell_index
				chi_score, label = get_label(this_pat, background, mask, this_shell_index, args.thres)
				all_score.append(chi_score)
				pi += 1
				num_pattern += 1
				if label > 0:
					num_hits += 1
					hits.append(this_pat)
					hits_serial.append(k)
					write_log(log_file, ["processed", "hits"], [num_pattern, num_hits])
			else:
				if m_rank == 0: print("Unknown data file format (%s)." % fext)
				sys.exit(0)
			# save results
			if len(hits) > 0:
				with h5py.File(result_h5_file, "a") as fp:
					fp.create_dataset("data_%d/hits/data" % j, data=hits, chunks=True, compression="gzip")
					fp.create_dataset("data_%d/chi_score" % j, data=all_score)
					fp.create_dataset("data_%d/hits/index" % j, data=hits_serial)
					fp.create_dataset("data_%d/RawDataPathString" % j, data="%s::%s"%(file,dt))
			# clear buffer
			hits.clear()
			hits_serial.clear()
			all_score.clear()

	write_log(log_file, ["processed", "hits"], [num_pattern, num_hits])
	print("- Rank %d : Finish." % m_rank)

	# write log, update processed image and time
	num_pattern = comm.reduce(num_pattern, op=MPI.SUM, root=0)
	num_hits = comm.reduce(num_hits, op=MPI.SUM, root=0)
	if m_rank == 0:
		end_time = time.time()
		log_file = os.path.join(args.outfolder, "hit_finding.stat")
		write_log(log_file, ["processed", "hits", "time"], [num_pattern, num_hits, end_time-start_time])
